name: Mapt Provision Test

on:
  pull_request:
    branches:
      - KFLUXDP-333
    paths:
      - 'tasks/mapt-oci/kind-aws-spot/provision/**'
      - 'tasks/mapt-oci/kind-aws-spot/deprovision/**'
      - '.github/workflows/mapt-provision-test.yaml'
    types:
      - opened
      - synchronize
      - reopened
  merge_group:
    types:
      - checks_requested

# Central configuration for the workflow
env:
  MAPT_ARCH: arm64
  MAPT_CPUS: 1
  MAPT_MEMORY: 2
  MAPT_SPOT: "true"
  MAPT_SPOT_INCREASE_RATE: 10
  MAPT_TIMEOUT: 15m
  CLUSTER_ID: pr-${{ github.event.number }}-${{ github.run_id }}
  KIND_VERSION: v0.20.0

jobs:
  test-provision-deprovision:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: 1. Checkout Repository
        uses: actions/checkout@v4

      - name: 2. Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: 3. Find Cheapest AWS Spot Region for ARM
        id: cheapest_region
        run: |
          echo "üîé Searching for the cheapest AWS region for a t4g.small (arm64) spot instance..."
          REGIONS=$(aws ec2 describe-regions --query "Regions[?OptInStatus=='opt-in-not-required' || OptInStatus=='opted-in'].RegionName" --output text)
          BEST_REGION=""
          MIN_PRICE="999.0"
          for REGION in $REGIONS; do
            PRICE=$(aws ec2 describe-spot-price-history --instance-types t4g.small --product-descriptions "Linux/UNIX (Amazon VPC)" --start-time $(date -u +%Y-%m-%dT%H:%M:%SZ) --max-items 1 --region "$REGION" --query "SpotPriceHistory[0].SpotPrice" --output text 2>/dev/null)
            if [ -n "$PRICE" ] && awk -v price="$PRICE" -v min_price="$MIN_PRICE" 'BEGIN {exit !(price < min_price)}'; then
              MIN_PRICE=$PRICE
              BEST_REGION=$REGION
            fi
          done
          if [ -z "$BEST_REGION" ]; then BEST_REGION="us-east-1"; fi
          echo "‚úÖ Cheapest region found: $BEST_REGION at \$${MIN_PRICE}/hour"
          echo "region=${BEST_REGION}" >> $GITHUB_OUTPUT

      - name: 4. Create Temporary S3 Bucket
        id: s3_bucket
        run: |
          BUCKET_NAME="mapt-test-bucket-${{ github.run_id }}-${{ github.run_attempt }}"
          REGION="${{ steps.cheapest_region.outputs.region }}"
          echo "ü™£ Creating S3 bucket '$BUCKET_NAME' in region '$REGION'..."
          if [ "$REGION" = "us-east-1" ]; then
            aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$REGION"
          else
            aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$REGION" --create-bucket-configuration LocationConstraint="$REGION"
          fi
          echo "name=${BUCKET_NAME}" >> $GITHUB_OUTPUT

      - name: 5. Spin up KinD Cluster
        uses: helm/kind-action@v1.10.0
        with:
          version: ${{ env.KIND_VERSION }}
      
      - name: 6. Install Tekton ‚úÖ
        run: |
          kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
          echo "‚è≥ Waiting for Tekton controller and webhook pods to be ready..."
          # Wait specifically for the controller and webhook with an increased timeout
          kubectl wait --for=condition=ready pod -l app=tekton-pipelines-controller -n tekton-pipelines --timeout=300s
          kubectl wait --for=condition=ready pod -l app=tekton-pipelines-webhook -n tekton-pipelines --timeout=300s

      - name: 7. Show Tekton Pod Status on Failure
        if: failure()
        run: |
          echo "::error::Tekton installation failed. Dumping pod status for debugging..."
          kubectl get pods -n tekton-pipelines -o wide
          echo "---"
          kubectl describe pods -n tekton-pipelines
      
      - name: 8. Create Kubernetes Secret for Tekton
        run: |
          kubectl create secret generic aws-credentials --from-literal=access-key="${{ secrets.AWS_ACCESS_KEY_ID }}" --from-literal=secret-key="${{ secrets.AWS_SECRET_ACCESS_KEY }}" --from-literal=region="${{ steps.cheapest_region.outputs.region }}" --from-literal=bucket="${{ steps.s3_bucket.outputs.name }}"
      
      - name: 9. Run Tekton Provision & Deprovision Pipeline
        env:
          CLUSTER_ID: ${{ env.CLUSTER_ID }}
        run: |
          # The original Step 7 is now Step 8, and so on.
          kubectl apply -f tasks/mapt-oci/kind-aws-spot/provision/0.1/kind-aws-provision.yaml
          kubectl apply -f tasks/mapt-oci/kind-aws-spot/deprovision/0.1/kind-aws-deprovision.yaml

          cat <<EOF | kubectl apply -f -
          apiVersion: tekton.dev/v1
          kind: Pipeline
          metadata:
            name: test-aws-kind-lifecycle
          spec:
            params:
              - name: id
            tasks:
              - name: mapt-provision
                taskRef:
                  name: kind-aws-provision
                params:
                  - name: id
                    value: \$(params.id)
                  - name: secret-aws-credentials
                    value: "aws-credentials"
                  - name: ownerName
                    value: \$(context.pipelineRun.name)
                  - name: ownerUid
                    value: \$(context.pipelineRun.uid)
                  - name: arch
                    value: '${{ env.MAPT_ARCH }}'
                  - name: cpus
                    value: '${{ env.MAPT_CPUS }}'
                  - name: memory
                    value: '${{ env.MAPT_MEMORY }}'
                  - name: spot
                    value: '${{ env.MAPT_SPOT }}'
                  - name: spot-increase-rate
                    value: '${{ env.MAPT_SPOT_INCREASE_RATE }}'
                  - name: timeout
                    value: '${{ env.MAPT_TIMEOUT }}'

              - name: mapt-deprovision
                runAfter: ["mapt-provision"]
                taskRef:
                  name: kind-aws-deprovision
                params:
                  - name: id
                    value: \$(params.id)
                  - name: secret-aws-credentials
                    value: "aws-credentials"
                  - name: cluster-access-secret
                    value: \$(tasks.mapt-provision.results.cluster-access-secret)
          ---
          apiVersion: tekton.dev/v1
          kind: PipelineRun
          metadata:
            name: test-\${CLUSTER_ID}
          spec:
            pipelineRef:
              name: test-aws-kind-lifecycle
            params:
              - name: id
                value: \${CLUSTER_ID}
          EOF

      - name: 10. Monitor PipelineRun for Completion
        env:
          CLUSTER_ID: ${{ env.CLUSTER_ID }}
        run: |
          PIPELINERUN_NAME="test-${CLUSTER_ID}"
          # Install tkn CLI for easier log parsing
          curl -sL https://raw.githubusercontent.com/tektoncd/cli/main/scripts/installer/stable | bash >/dev/null 2>&1 && mv ./tkn /usr/local/bin/
          
          tkn pipelinerun logs "\${PIPELINERUN_NAME}" -f &
          LOGS_PID=\$!
          
          for i in {1..120}; do
            STATUS=\$(kubectl get pipelinerun "\${PIPELINERUN_NAME}" -o jsonpath='{.status.conditions[0].status}' 2>/dev/null)
            REASON=\$(kubectl get pipelinerun "\${PIPELINERUN_NAME}" -o jsonpath='{.status.conditions[0].reason}' 2>/dev/null)
            if [ "\$STATUS" == "True" ]; then echo "‚úÖ PipelineRun Succeeded."; kill \$LOGS_PID; exit 0; fi
            if [ "\$STATUS" == "False" ]; then echo "::error::PipelineRun Failed with reason: \$REASON."; kill \$LOGS_PID; exit 1; fi
            sleep 10
          done
          echo "::error::PipelineRun timed out after 20 minutes."
          kill \$LOGS_PID
          exit 1

      - name: 11. Cleanup Temporary S3 Bucket
        if: always()
        run: |
          BUCKET_NAME="${{ steps.s3_bucket.outputs.name }}"
          if [ -n "$BUCKET_NAME" ]; then
            echo "üßπ Cleaning up S3 bucket '$BUCKET_NAME'..."
            aws s3 rb "s3://${BUCKET_NAME}" --force
            echo "‚úÖ Cleanup complete."
          fi
