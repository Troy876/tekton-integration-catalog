name: Mapt Provision Test

on:
  pull_request:
    branches:
      - KFLUXDP-333
    paths:
      - 'tasks/mapt-oci/kind-aws-spot/provision/**'
      - 'tasks/mapt-oci/kind-aws-spot/deprovision/**'
      - '.github/workflows/mapt-provision-test.yaml'
    types:
      - opened
      - synchronize
      - reopened
  merge_group:
    types:
      - checks_requested

# Central configuration for the workflow
env:
  MAPT_ARCH: arm64
  MAPT_CPUS: 1
  MAPT_MEMORY: 2
  MAPT_SPOT: "true"
  MAPT_SPOT_INCREASE_RATE: 10
  MAPT_TIMEOUT: 15m
  CLUSTER_ID: pr-${{ github.event.number }}-${{ github.run_id }}

jobs:
  test-provision-deprovision:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: 1. Checkout Repository
        uses: actions/checkout@v4

      - name: 2. Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: 3. Find Cheapest AWS Spot Region for ARM
        id: cheapest_region
        run: |
          echo "üîé Searching for the cheapest AWS region for a t4g.small (arm64) spot instance..."
          REGIONS=$(aws ec2 describe-regions --query "Regions[?OptInStatus=='opt-in-not-required' || OptInStatus=='opted-in'].RegionName" --output text)
          BEST_REGION=""
          MIN_PRICE="999.0"
          for REGION in $REGIONS; do
            PRICE=$(aws ec2 describe-spot-price-history --instance-types t4g.small --product-descriptions "Linux/UNIX (Amazon VPC)" --start-time $(date -u +%Y-%m-%dT%H:%M:%SZ) --max-items 1 --region "$REGION" --query "SpotPriceHistory[0].SpotPrice" --output text 2>/dev/null)
            if [ -n "$PRICE" ] && awk -v price="$PRICE" -v min_price="$MIN_PRICE" 'BEGIN {exit !(price < min_price)}'; then
              MIN_PRICE=$PRICE
              BEST_REGION=$REGION
            fi
          done
          if [ -z "$BEST_REGION" ]; then BEST_REGION="us-east-1"; fi
          echo "‚úÖ Cheapest region found: $BEST_REGION at \$${MIN_PRICE}/hour"
          echo "region=${BEST_REGION}" >> $GITHUB_OUTPUT

      - name: 4. Create Temporary S3 Bucket
        id: s3_bucket
        run: |
          BUCKET_NAME="mapt-test-bucket-${{ github.run_id }}-${{ github.run_attempt }}"
          REGION="${{ steps.cheapest_region.outputs.region }}"
          echo "ü™£ Creating S3 bucket '$BUCKET_NAME' in region '$REGION'..."
          if [ "$REGION" = "us-east-1" ]; then
            aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$REGION"
          else
            aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$REGION" --create-bucket-configuration LocationConstraint="$REGION"
          fi
          echo "name=${BUCKET_NAME}" >> $GITHUB_OUTPUT

      - name: 5. Spin up KinD Cluster
        uses: helm/kind-action@v1.10.0
        with:
          version: v0.23.0
      
      - name: 6. Install Tekton
        run: |
          kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
          echo "‚è≥ Waiting for Tekton controller and webhook pods to be ready..."
          kubectl wait --for=condition=ready pod -l app=tekton-pipelines-controller -n tekton-pipelines --timeout=300s
          kubectl wait --for=condition=ready pod -l app=tekton-pipelines-webhook -n tekton-pipelines --timeout=300s

      - name: 7. Show Tekton Pod Status on Failure
        if: failure()
        run: |
          echo "::error::Tekton installation failed. Dumping pod status for debugging..."
          kubectl get pods -n tekton-pipelines -o wide
          echo "---"
          kubectl describe pods -n tekton-pipelines
      
      - name: 8. Create Kubernetes Secret for Tekton
        run: |
          kubectl create secret generic aws-credentials --from-literal=access-key="${{ secrets.AWS_ACCESS_KEY_ID }}" --from-literal=secret-key="${{ secrets.AWS_SECRET_ACCESS_KEY }}" --from-literal=region="${{ steps.cheapest_region.outputs.region }}" --from-literal=bucket="${{ steps.s3_bucket.outputs.name }}"
      
      - name: 9. Run Tekton Provision & Deprovision Pipeline
        env:
          CLUSTER_ID: ${{ env.CLUSTER_ID }}
        run: |
          LOWERCASE_CLUSTER_ID=$(echo "$CLUSTER_ID" | tr '[:upper:]' '[:lower:]')

          echo "Waiting for Tekton webhook to become available..."
          sleep 10
          kubectl wait --for=condition=Available --timeout=60s deployment/tekton-pipelines-webhook -n tekton-pipelines

          kubectl apply -f tasks/mapt-oci/kind-aws-spot/provision/0.1/kind-aws-provision.yaml
          kubectl apply -f tasks/mapt-oci/kind-aws-spot/deprovision/0.1/kind-aws-deprovision.yaml

          cat <<EOF | kubectl apply -f -
          apiVersion: tekton.dev/v1
          kind: Pipeline
          metadata:
            name: test-aws-kind-lifecycle
          spec:
            params:
              - name: id
            tasks:
              - name: mapt-provision
                taskRef:
                  name: kind-aws-provision
                params:
                  - name: id
                    value: \$(params.id)
                  - name: secret-aws-credentials
                    value: "aws-credentials"
                  - name: ownerName
                    value: \$(context.pipelineRun.name)
                  - name: ownerUid
                    value: \$(context.pipelineRun.uid)
                  - name: arch
                    value: '${{ env.MAPT_ARCH }}'
                  - name: cpus
                    value: '${{ env.MAPT_CPUS }}'
                  - name: memory
                    value: '${{ env.MAPT_MEMORY }}'
                  - name: spot
                    value: '${{ env.MAPT_SPOT }}'
                  - name: spot-increase-rate
                    value: '${{ env.MAPT_SPOT_INCREASE_RATE }}'
                  - name: timeout
                    value: '${{ env.MAPT_TIMEOUT }}'

              - name: mapt-deprovision
                runAfter: ["mapt-provision"]
                taskRef:
                  name: kind-aws-deprovision
                params:
                  - name: id
                    value: \$(params.id)
                  - name: secret-aws-credentials
                    value: "aws-credentials"
                  - name: cluster-access-secret
                    value: \$(tasks.mapt-provision.results.cluster-access-secret)
          ---
          apiVersion: tekton.dev/v1
          kind: PipelineRun
          metadata:
            name: test-${LOWERCASE_CLUSTER_ID}
          spec:
            pipelineRef:
              name: test-aws-kind-lifecycle
            params:
              - name: id
                value: ${LOWERCASE_CLUSTER_ID}
          EOF

      - name: 10. Monitor PipelineRun for Completion
        env:
          CLUSTER_ID: ${{ env.CLUSTER_ID }}
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.
          
          LOWERCASE_CLUSTER_ID=$(echo "$CLUSTER_ID" | tr '[:upper:]' '[:lower:]')
          PIPELINERUN_NAME="test-${LOWERCASE_CLUSTER_ID}"

          echo "Installing Tekton CLI (tkn)..."
          # Download and run the installer script. We let its output show to diagnose any issues.
          curl -sL https://raw.githubusercontent.com/tektoncd/cli/main/scripts/installer/stable | bash
          # The script downloads 'tkn' to the current directory. Move it to a globally accessible location.
          sudo mv ./tkn /usr/local/bin/
          echo "Verifying tkn installation..."
          tkn version

          echo "Streaming logs for PipelineRun '${PIPELINERUN_NAME}'..."
          # Use the 'timeout' command to wait for a maximum of 20 minutes (1200s).
          # 'tkn logs -f' will stream logs and exit when the PipelineRun completes.
          # We add '|| true' so the script doesn't exit if 'timeout' kills the process.
          timeout 1200s tkn pipelinerun logs "${PIPELINERUN_NAME}" -f || true

          echo "Checking final status of PipelineRun '${PIPELINERUN_NAME}'..."
          # Use 'tkn describe' with jsonpath to get the final status.
          STATUS=$(tkn pipelinerun describe "${PIPELINERUN_NAME}" -o jsonpath='{.status.conditions[0].status}')
          REASON=$(tkn pipelinerun describe "${PIPELINERUN_NAME}" -o jsonpath='{.status.conditions[0].reason}')

          if [ "$STATUS" == "True" ]; then
            echo "‚úÖ PipelineRun Succeeded."
            exit 0
          elif [ "$STATUS" == "False" ]; then
            echo "::error::PipelineRun Failed with reason: ${REASON}."
            exit 1
          else
            echo "::error::PipelineRun timed out or ended in an unknown state (Status: ${STATUS})."
            # It's helpful to dump the full status for debugging timeouts
            tkn pipelinerun describe "${PIPELINERUN_NAME}"
            exit 1
          fi

      - name: 11. Cleanup Temporary S3 Bucket
        if: always()
        run: |
          BUCKET_NAME="${{ steps.s3_bucket.outputs.name }}"
          if [ -n "$BUCKET_NAME" ]; then
            echo "üßπ Cleaning up S3 bucket '$BUCKET_NAME'..."
            aws s3 rb "s3://${BUCKET_NAME}" --force
            echo "‚úÖ Cleanup complete."
          fi
